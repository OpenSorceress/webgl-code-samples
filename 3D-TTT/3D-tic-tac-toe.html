<!DOCTYPE html>
<html lang="en">
<head>
  <title>3D Tic-Tac-Toe</title>
  <!-- All demo code is here or available on my github account under code-samples
       https://github.com/cubicleDowns/code-samples  -->

  <link rel="stylesheet" href="css/demo.css" type="text/css">

  <script src="lib/jquery-1.9.1.min.js"></script>
  <script src="lib/three.v63.min.js"></script>
  <script src="lib/detector.js"></script>
  <script src="lib/stats.min.js"></script>

  <script src="js/scene.js"></script>
  <script src="js/camera.js"></script>
  <script src="js/setup.js"></script>
  <script src="js/orbit-control.js"></script>

</head>
<body>
<div id="ray-intersection"></div>
<h3>Click on the canvas to project a ray and intersect a cube in the Three.js scene</h3>
<ul class='info'><li>jQuery: v<span id="jqv"></span> | </li><li> THREE.js: v<span id="tjsv"></span></li></ul>
<h2><a href="http://blog.tempt3d.com/">Blog.tempt3d.com</a></h3>

</body>

  <script>

    // GLOBAL anchor for requestAnimationFrame browser hooks
    var _demo,
        delta = 25,
        cubeDim = 10,
        turn = 1,
        userColor1,
        userColor2;

    function init() {
      $('#jqv').text($.fn.jquery);
      $('#tjsv').text(THREE.REVISION);

      _demo = new Demo.Scene("ray-intersection");
      // _demo.rotateCamera = true;
      listeners();

      createCubes();
      createRays();

      // start the animation
      // this also does all of the setup.  i've encapsulated all of this work for brevity.
      _demo.animate();
    }

    function createCubes() {

      var i,j,k
        geo = new THREE.CubeGeometry(cubeDim, cubeDim, cubeDim),
        materialVerts = new THREE.MeshLambertMaterial({color: _demo.setup.randomColor()});
        materialOutside = new THREE.MeshLambertMaterial({color: _demo.setup.randomColor()}),
        materialInside = new THREE.MeshLambertMaterial({color: _demo.setup.randomColor()});

      userColor1 = _demo.setup.randomColor();
      userColor2 = _demo.setup.randomColor();

      for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){
          for(k = 0; k < 3; k++){
            var mat;

            // center cube
            if(i * j * k === 1){
              mat = materialInside;
            } else if (i * j === 1 || i * k === 1 || j * k === 1) {  // axis cubes
              mat = materialVerts;
            } else {
              mat = materialOutside;
            }
            var mesh = new THREE.Mesh(geo.clone(), mat.clone());
            _demo.collisions.push(mesh);

            mesh.position = new THREE.Vector3((i-1)*delta, (j-1)*delta, (k-1)*delta);
            _demo.scene.add(mesh);
          }
        }
      }
    }

    function createRays() {
      var i,j,k,
          x,y,z,
          length = 50,
          xDirection = new THREE.Vector3(-1,0,0),
          yDirection = new THREE.Vector3(0,-1,0),
          zDirection = new THREE.Vector3(0,0,-1),
          xy1Direction = new THREE.Vector3(-1,-1,0),
          xy2Direction = new THREE.Vector3(-1,1,0),
          xz1Direction = new THREE.Vector3(-1,0,-1),
          xz2Direction = new THREE.Vector3(-1,0,1),
          yz1Direction = new THREE.Vector3(0,-1,-1),
          yz2Direction = new THREE.Vector3(0,1,-1),
          xyz1Direction = new THREE.Vector3(-1,-1,-1),
          xyz2Direction = new THREE.Vector3(1,-1,-1),
          xyz3Direction = new THREE.Vector3(-1,-1,1),
          xyz4Direction = new THREE.Vector3(1,-1,1),
          origin,
          color = 0x884400;

      var geo = new THREE.CubeGeometry(5, 5, 5);
      var mat = new THREE.MeshLambertMaterial({color: 0xFF0000});

      // create 9 rays looking down X
      for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){

          x = 4 * delta;
          y = (i - 1) * delta;
          z = (j - 1) * delta;

          var origin = new THREE.Vector3(x,y,z);
          var arrow = new THREE.ArrowHelper(xDirection, origin, length, 0xFF0000);
          arrow.cast = true;
          _demo.scene.add(arrow);

        }
      }

      // create 9 rays looking down Y
      for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){

          y = 4 * delta;
          x = (i - 1) * delta;
          z = (j - 1) * delta;

          var origin = new THREE.Vector3(x,y,z);
          var arrow = new THREE.ArrowHelper(yDirection, origin, length, 0x00FF00);
          arrow.cast = true;
          _demo.scene.add(arrow);

        }
      }

      // create 9 rays looking down Z
      for(i = 0; i < 3; i++){
        for(j = 0; j < 3; j++){

          z = 4 * delta;
          y = (i - 1) * delta;
          x = (j - 1) * delta;

          var origin = new THREE.Vector3(x,y,z);
          var arrow = new THREE.ArrowHelper(zDirection, origin, length, 0x0000FF);
          arrow.cast = true;
          _demo.scene.add(arrow);

        }
      }

      // create 6 rays for XY diagonals
      for(i = 0; i < 3; i++){

          x = 4 * delta;
          y = 4 * delta;
          z = (i - 1) * delta;
          var origin1 = new THREE.Vector3(x,y,z);
          var arrow1 = new THREE.ArrowHelper(xy1Direction.normalize(), origin1, length, 0xCC0000);
          _demo.scene.add(arrow1);

          var origin2 = new THREE.Vector3(x,-y,z);
          var arrow2 = new THREE.ArrowHelper(xy2Direction.normalize(), origin2, length, 0xCC0000);
          _demo.scene.add(arrow2);

      }

      // create 6 rays for XZ diagonals
      for(i = 0; i < 3; i++){

          x = 4 * delta;
          y = (i - 1) * delta;
          z = 4 * delta;
          origin1 = new THREE.Vector3(x,y,z);
          arrow1 = new THREE.ArrowHelper(xz1Direction.normalize(), origin1, length, 0x00CC00);
          _demo.scene.add(arrow1);

          origin2 = new THREE.Vector3(x,y,-z);
          arrow2 = new THREE.ArrowHelper(xz2Direction.normalize(), origin2, length, 0x00CC00);
          _demo.scene.add(arrow2);

      }
      // create 6 rays for YZ diagonals
      for(i = 0; i < 3; i++){

          x = (i - 1) * delta;
          y = 4 * delta;
          z = 4 * delta;
          origin1 = new THREE.Vector3(x,y,z);
          arrow1 = new THREE.ArrowHelper(yz1Direction.normalize(), origin1, length, 0x0000CC);
          _demo.scene.add(arrow1);

          origin2 = new THREE.Vector3(x,-y,z);
          arrow2 = new THREE.ArrowHelper(yz2Direction.normalize(), origin2, length, 0x0000CC);
          _demo.scene.add(arrow2);

      }

      // create 4 rays for XYZ diagonals
      var distance = 4 * delta;
      x = distance;
      y = distance;
      z = distance;
      origin1 = new THREE.Vector3(x,y,z);
      arrow1 = new THREE.ArrowHelper(xyz1Direction.normalize(), origin1, length, 0xFFFFFF);
      _demo.scene.add(arrow1);

      origin2 = new THREE.Vector3(-x,y,z);
      arrow2 = new THREE.ArrowHelper(xyz2Direction.normalize(), origin2, length, 0xFFFFFF);
      _demo.scene.add(arrow2);

      origin3 = new THREE.Vector3(x,y,-z);
      arrow3 = new THREE.ArrowHelper(xyz3Direction.normalize(), origin3, length, 0xFFFFFF);
      _demo.scene.add(arrow3);

      origin4 = new THREE.Vector3(-x,y,-z);
      arrow4 = new THREE.ArrowHelper(xyz4Direction.normalize(), origin4, length, 0xFFFFFF);
      _demo.scene.add(arrow4);
    }

    function listeners () {
      document.addEventListener('click', selectCube, false);
    }

    function selectCube (event) {

      event.preventDefault();

      var mouse = {};

      // since this isn't a full screen app, lets use the dimensions of the container div.
      // OFFSET change.  Now I'll adjust the offset of the canvas element from the click.
      var leftOffset = _demo.jqContainer.offset().left;
      var topOffset = _demo.jqContainer.offset().top;

      mouse.x = ((event.clientX - leftOffset) / _demo.jqContainer.width()) * 2 -1;
      mouse.y = -((event.clientY - topOffset) / _demo.jqContainer.height()) * 2 + 1;

      var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
      _demo.projector.unprojectVector(vector, _demo.cameras.liveCam);

      var ray = new THREE.Raycaster(_demo.cameras.liveCam.position, vector.sub(_demo.cameras.liveCam.position).normalize());

      // Casting a ray to find if there is an intersection.
      var intersected = ray.intersectObjects( _demo.collisions );

      // removing previous click marker.
      $(".clickMarkers").remove();

      // appending a click marker.
      _demo.jqContainer.append('<div class="clickMarkers" style="pointer-events:none; position: absolute; z-index: 100; left: ' + event.offsetX + 'px; top: ' + event.offsetY +'px">D</div>' );

      // only change the first (closest) intersected object.
      if(intersected.length > 0) {
        if(!intersected[0].object.ttt) {

          var color = (turn === -1) ? userColor1 : userColor2;
          // only change turn if selection legit
          turn *= -1;

          intersected[0].object.material.color = color;
          intersected[0].object.ttt = true;
        }
      }
    }

    $(document).ready(function () {
      init();
    });

  </script>

</html>

